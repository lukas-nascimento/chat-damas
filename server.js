// ============================================
// ARQUIVO: server.js (Next.js + WebSocket Integrado)
// CAMINHO: server.js (raiz do projeto)
// ============================================

const { createServer } = require('http');
const { parse } = require('url');
const next = require('next');
const WebSocket = require('ws');

const dev = process.env.NODE_ENV !== 'production';
const hostname = '0.0.0.0';
const port = parseInt(process.env.PORT, 10) || 3000;

const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

const users = new Map();
const bannedUsers = new Map();
const userViolations = new Map();
let userIdCounter = 1;

// Limites para economizar mem√≥ria
const MAX_BANNED_USERS = 100;
const MAX_VIOLATIONS_PER_USER = 5;
const MAX_MESSAGE_LENGTH = 1000;
const CLEANUP_INTERVAL = 5 * 60 * 1000; // 5 minutos

// Cores dispon√≠veis para usu√°rios
const USER_COLORS = ['crimson', 'gold', 'cadetblue', 'coral', 'teal', 'purple', 'deeppink', 'lime', 'orange', 'cyan'];

// ==========================================
// SISTEMA DE SEGURAN√áA
// ==========================================

const bannedWords = [
  'fake',
  'n√£o usa foto real',
  'nao usa foto real',
  'n√£o usa foto dele',
  'n√£o usa foto dela',
  'nao usa foto dele',
  'nao usa foto dela',
  'n√£o √© foto real',
  'nao e foto real',
  'foto n√£o √© real',
  'foto nao e real',
  'n√£o usa a foto real',
  'nao usa a foto real',
  'n√£o usa suas fotos',
  'nao usa suas fotos',
  'n√£o usa foto pr√≥pria',
  'nao usa foto propria',
  'essa pessoa n√£o √© real',
  'essa pessoa nao e real',
  'essa pessoa √© fake',
  'essa pessoa e fake',
  'ele n√£o √© real',
  'ele nao e real',
  'ela n√£o √© real',
  'ela nao e real',
  'n√£o √© pessoa real',
  'nao e pessoa real',
  'pessoa fake',
  'perfil fake',
  'conta fake',
  '√© fake',
  'e fake',
  'isso √© fake',
  'isso e fake',
  'ele usa fotos de outra pessoa',
  'ele usa foto de outra pessoa',
  'ela usa fotos de outra pessoa',
  'ela usa foto de outra pessoa',
  'usa foto de outro',
  'usa foto de outra',
  'usa fotos de outro',
  'usa fotos de outra',
  'usa foto alheia',
  'usa fotos alheias',
  'essa foto n√£o √© dela',
  'essa foto n√£o √© dele',
  'roubou foto',
  'roubou fotos',
  'foto roubada',
  'fotos roubadas',
  'pegou foto de outro',
  'pegou foto de outra',
  'pegou fotos de outro',
  'pegou fotos de outra',
  'copiou foto',
  'copiou fotos',
  'foto de terceiro',
  'fotos de terceiro',
  'n√£o √© ele na foto',
  'nao e ele na foto',
  'n√£o √© ela na foto',
  'nao e ela na foto',
  'foto n√£o √© dele',
  'foto nao e dele',
  'foto n√£o √© dela',
  'foto nao e dela',
  'fotos n√£o s√£o dele',
  'fotos nao sao dele',
  'fotos n√£o s√£o dela',
  'fotos nao sao dela',
  'usa ft de outro',
  'usa ft de outra',
  'ft fake',
  'foto fake',
  'fotos fake',
  'perfil falso',
  'conta falsa',
  'n√£o √© verdadeiro',
  'nao e verdadeiro',
  'n√£o √© verdadeira',
  'nao e verdadeira',
  'mentiroso',
  'mentirosa',
  'enganador',
  'enganadora',
  'catfish',
  'pedofilia',
  'pedofilo',
  'ped√≥filo',
  'droga',
  'trafico',
  'tr√°fico',
  'hack',
  'hacker',
  'cracker',
  'terrorismo',
  'terrorista',
  'golpe',
  'fraude',
  'cp',
  'scam',
  'phishing',
  'estupro',
  'assassinato',
  'suicidio',
  'suic√≠dio'
];

const urlRegex = /(https?:\/\/[^\s]+)|(www\.[^\s]+)|([a-zA-Z0-9-]+\.(com|net|org|br|io|gov|edu|co|tv|me|app|dev)[^\s]*)/gi;

function containsLink(message) {
  return urlRegex.test(message);
}

function findBannedWord(message) {
  const lowerMessage = message.toLowerCase();
  return bannedWords.find(word => {
    if (word.includes(' ')) {
      return lowerMessage.includes(word.toLowerCase());
    } else {
      const regex = new RegExp(`\\b${word}\\b`, 'i');
      return regex.test(lowerMessage);
    }
  });
}

function banUser(ws, userId, userName, reason) {
  if (bannedUsers.size >= MAX_BANNED_USERS) {
    const oldestKey = bannedUsers.keys().next().value;
    bannedUsers.delete(oldestKey);
  }

  bannedUsers.set(userId, {
    reason,
    timestamp: Date.now(),
    userName
  });

  console.log(`üö´ BANIDO: ${userName} (ID: ${userId}) - ${reason}`);

  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: 'user_banned',
      data: { reason, timestamp: Date.now() }
    }));
  }

  broadcastEvent('user_banned_notification', { userId, userName, reason });
  users.delete(ws);
  ws.close(1008, `Banido: ${reason}`);
  updateOnlineCount();
}

function validateMessage(message, ws, user) {
  console.log(`üîç Validando mensagem de ${user.name}: "${message}"`);

  if (bannedUsers.has(user.id)) {
    const banInfo = bannedUsers.get(user.id);
    console.log(`‚ùå Usu√°rio ${user.name} j√° est√° banido`);
    ws.send(JSON.stringify({
      type: 'message_blocked',
      data: { reason: `Voc√™ est√° banido: ${banInfo.reason}` }
    }));
    ws.close();
    return false;
  }

  if (message.length > MAX_MESSAGE_LENGTH) {
    console.log(`‚ùå Mensagem muito longa de ${user.name}`);
    ws.send(JSON.stringify({
      type: 'message_blocked',
      data: { reason: 'Mensagem muito longa' }
    }));
    return false;
  }

  if (containsLink(message)) {
    console.log(`‚ö†Ô∏è LINK DETECTADO de ${user.name}: "${message}"`);
    
    if (!userViolations.has(user.id)) {
      userViolations.set(user.id, []);
    }
    const violations = userViolations.get(user.id);
    
    if (violations.length >= MAX_VIOLATIONS_PER_USER) {
      violations.shift();
    }
    
    violations.push({
      type: 'LINK',
      timestamp: Date.now()
    });

    banUser(ws, user.id, user.name, 'Envio de links n√£o autorizado');
    return false;
  }

  const bannedWord = findBannedWord(message);
  if (bannedWord) {
    console.log(`‚ö†Ô∏è PALAVRA PROIBIDA de ${user.name}: "${bannedWord}" na mensagem: "${message}"`);
    
    if (!userViolations.has(user.id)) {
      userViolations.set(user.id, []);
    }
    const violations = userViolations.get(user.id);
    
    if (violations.length >= MAX_VIOLATIONS_PER_USER) {
      violations.shift();
    }
    
    violations.push({
      type: 'BANNED_WORD',
      word: bannedWord,
      timestamp: Date.now()
    });

    banUser(ws, user.id, user.name, `Uso de conte√∫do inadequado: "${bannedWord}"`);
    return false;
  }

  console.log(`‚úÖ Mensagem v√°lida de ${user.name}`);
  return true;
}

function broadcastEvent(type, data) {
  const message = JSON.stringify({ type, data });
  let successCount = 0;
  let errorCount = 0;

  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      try {
        client.send(message);
        successCount++;
      } catch (err) {
        errorCount++;
        console.error('‚ùå Erro ao enviar broadcast:', err.message);
      }
    }
  });

  console.log(`üì° Broadcast ${type}: ${successCount} enviados, ${errorCount} erros`);
}

function updateOnlineCount() {
  // Limpar conex√µes fechadas
  for (const [ws, user] of users.entries()) {
    if (ws.readyState !== WebSocket.OPEN) {
      console.log(`üßπ Removendo usu√°rio desconectado: ${user.name}`);
      users.delete(ws);
    }
  }

  const usersList = Array.from(users.values()).map(u => ({
    id: u.id,
    name: u.name
  }));

  console.log(`üë• Usu√°rios online: ${usersList.length}`);

  broadcastEvent('online_count', {
    count: usersList.length,
    users: usersList
  });
}

function cleanup() {
  console.log('üßπ Executando limpeza de mem√≥ria...');
  
  const oneHourAgo = Date.now() - 60 * 60 * 1000;
  for (const [userId, violations] of userViolations.entries()) {
    const recentViolations = violations.filter(v => v.timestamp > oneHourAgo);
    if (recentViolations.length === 0) {
      userViolations.delete(userId);
    } else {
      userViolations.set(userId, recentViolations);
    }
  }

  const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
  for (const [userId, banInfo] of bannedUsers.entries()) {
    if (banInfo.timestamp < oneDayAgo) {
      bannedUsers.delete(userId);
    }
  }

  if (global.gc) {
    global.gc();
    console.log('‚ôªÔ∏è Garbage collection executado');
  }

  const used = process.memoryUsage();
  console.log(`üíæ Mem√≥ria ap√≥s limpeza: ${Math.round(used.heapUsed / 1024 / 1024)}MB`);
}

// Vari√°vel global para o WebSocket Server
let wss;

app.prepare().then(() => {
  const server = createServer(async (req, res) => {
    try {
      const parsedUrl = parse(req.url, true);
      await handle(req, res, parsedUrl);
    } catch (err) {
      console.error('Error occurred handling', req.url, err);
      res.statusCode = 500;
      res.end('internal server error');
    }
  });

  // WebSocket Server integrado
  wss = new WebSocket.Server({ 
    server,
    maxPayload: 10 * 1024 * 1024,
    perMessageDeflate: {
      zlibDeflateOptions: {
        chunkSize: 1024,
        memLevel: 7,
        level: 3
      },
      zlibInflateOptions: {
        chunkSize: 10 * 1024
      },
      threshold: 1024
    }
  });

  console.log(`üöÄ Servidor Next.js + WebSocket iniciando...`);
  console.log(`üìä Max Payload: 10MB`);
  console.log(`üõ°Ô∏è Sistema de seguran√ßa ativado!`);
  console.log(`üíæ Modo economia de mem√≥ria ativado`);

  wss.on('connection', (ws) => {
    const userId = userIdCounter++;
    const userName = `Usu√°rio ${userId}`;
    const userColor = USER_COLORS[userId % USER_COLORS.length];
    ws.isAlive = true;

    console.log(`üîå Nova conex√£o: ${userName} (ID: ${userId}, Cor: ${userColor})`);

    if (bannedUsers.has(userId)) {
      const banInfo = bannedUsers.get(userId);
      console.log(`‚ùå Tentativa de conex√£o de usu√°rio banido: ${userId}`);
      ws.send(JSON.stringify({
        type: 'user_banned',
        data: banInfo
      }));
      ws.close();
      return;
    }

    // Armazenar usu√°rio no Map
    users.set(ws, { id: userId, name: userName, color: userColor });

    // CORRE√á√ÉO: Enviar dados no formato correto
    ws.send(JSON.stringify({
      type: 'user_id',
      data: { 
        id: userId, 
        name: userName,
        color: userColor
      }
    }));

    console.log(`‚úÖ Usu√°rio registrado: ${userName}`);

    updateOnlineCount();

    ws.on('pong', () => {
      ws.isAlive = true;
      console.log(`üíì Pong recebido de ${users.get(ws)?.name}`);
    });

    ws.on('message', (msg) => {
      try {
        const message = JSON.parse(msg);
        const user = users.get(ws);
        
        console.log(`üì• Mensagem recebida - Tipo: ${message.type}, User: ${user?.name || 'DESCONHECIDO'}`);

        if (!user) {
          console.error('‚ùå ERRO: Usu√°rio n√£o encontrado no Map!');
          console.error('‚ùå WebSocket registrado?', users.has(ws));
          console.error('‚ùå Total de usu√°rios:', users.size);
          return;
        }

        if (message.type === 'set_name') {
          const newName = message.data || user.name;
          console.log(`‚úèÔ∏è Alterando nome: ${user.name} ‚Üí ${newName}`);
          user.name = newName;
          users.set(ws, user);
          updateOnlineCount();
        }

        else if (message.type === 'message') {
          console.log(`üí¨ Processando mensagem de texto: "${message.data}"`);
          
          if (!validateMessage(message.data, ws, user)) {
            console.log('‚ùå Mensagem bloqueada pela valida√ß√£o');
            return;
          }

          console.log(`üì§ Broadcasting mensagem de ${user.name}`);
          broadcastEvent('message', {
            userId: user.id,
            userName: user.name,
            content: message.data,
            timestamp: Date.now()
          });
        }

        else if (message.type === 'audio_message') {
          console.log(`üé§ √Åudio recebido de ${user.name}`);
          broadcastEvent('audio_message', {
            userId: user.id,
            userName: user.name,
            content: message.data.audio,
            timestamp: Date.now()
          });
        }

        else if (message.type === 'image_message') {
          console.log(`üñºÔ∏è Imagem recebida de ${user.name}`);
          broadcastEvent('image_message', {
            userId: user.id,
            userName: user.name,
            content: message.data.image,
            fileName: message.data.fileName || 'imagem.png',
            timestamp: Date.now()
          });
        }

        else if (message.type === 'video_message') {
          console.log(`üé• Tentativa de envio de v√≠deo por ${user.name}`);
          ws.send(JSON.stringify({
            type: 'message_blocked',
            data: { reason: 'V√≠deos temporariamente desabilitados para economia de mem√≥ria' }
          }));
        }

        else if (message.type === 'sticker_message') {
          console.log(`üòä Sticker enviado por ${user.name}`);
          broadcastEvent('sticker_message', {
            userId: user.id,
            userName: user.name,
            content: message.data.sticker,
            timestamp: Date.now()
          });
        }

        else if (message.type === 'typing_start' || message.type === 'typing_stop') {
          console.log(`‚å®Ô∏è ${user.name} ${message.type === 'typing_start' ? 'come√ßou' : 'parou'} de digitar`);
          broadcastEvent('user_typing', {
            userId: user.id,
            userName: user.name,
            isTyping: message.type === 'typing_start'
          });
        }

        else {
          console.log(`‚ö†Ô∏è Tipo de mensagem desconhecido: ${message.type}`);
        }

      } catch (err) {
        console.error('‚ùå Erro ao processar mensagem:', err.message);
        console.error('‚ùå Stack:', err.stack);
      }
    });

    ws.on('close', (code, reason) => {
      const user = users.get(ws);
      console.log(`üîå Conex√£o fechada - Code: ${code}, Reason: ${reason || 'Sem raz√£o'}`);
      
      if (user) {
        console.log(`üëã Usu√°rio desconectado: ${user.name} (ID: ${user.id})`);
        users.delete(ws);
        updateOnlineCount();
      } else {
        console.log('‚ö†Ô∏è Conex√£o fechada mas usu√°rio n√£o estava no Map');
      }
    });

    ws.on('error', (err) => {
      const user = users.get(ws);
      console.error('‚ùå Erro WebSocket:', err.message);
      if (user) {
        console.error(`‚ùå Erro do usu√°rio: ${user.name} (ID: ${user.id})`);
      }
    });
  });

  // Heartbeat para detectar conex√µes mortas
  setInterval(() => {
    console.log('üíì Executando heartbeat check...');
    let terminated = 0;
    
    wss.clients.forEach(ws => {
      if (!ws.isAlive) {
        console.log(`üíÄ Terminando conex√£o inativa: ${users.get(ws)?.name}`);
        users.delete(ws);
        terminated++;
        return ws.terminate();
      }
      ws.isAlive = false;
      ws.ping();
    });

    if (terminated > 0) {
      console.log(`üíÄ ${terminated} conex√£o(√µes) terminada(s)`);
      updateOnlineCount();
    }
  }, 30000);

  // Limpeza de mem√≥ria
  setInterval(cleanup, CLEANUP_INTERVAL);

  // Monitor de mem√≥ria
  setInterval(() => {
    const used = process.memoryUsage();
    const memMB = Math.round(used.heapUsed / 1024 / 1024);
    console.log(`üíæ Mem√≥ria: ${memMB}MB | Usu√°rios: ${users.size} | Banidos: ${bannedUsers.size}`);
    
    if (memMB > 400) {
      console.log('‚ö†Ô∏è ALERTA: Mem√≥ria alta! Executando limpeza...');
      cleanup();
    }
  }, 60000);

  server.listen(port, (err) => {
    if (err) throw err;
    console.log(`‚úÖ Servidor rodando em http://${hostname}:${port}`);
    console.log(`üåê WebSocket dispon√≠vel em wss://chat-damas.onrender.com`);
  });

  // Encerramento gracioso
  process.on('SIGINT', () => {
    console.log('‚èπÔ∏è Encerrando servidor...');
    users.clear();
    bannedUsers.clear();
    userViolations.clear();
    wss.close(() => process.exit(0));
  });
});