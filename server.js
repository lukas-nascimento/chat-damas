// ============================================
// ARQUIVO: server.js (COMPLETO E CORRIGIDO)
// CAMINHO: /server.js (raiz do projeto)
// ============================================

const WebSocket = require('ws');
const http = require('http');

const PORT = process.env.PORT || 8080;

// Criar servidor HTTP
const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('WebSocket Server Running');
});

// Criar servidor WebSocket
const wss = new WebSocket.Server({ server });

// Armazenar usu√°rios conectados
const users = new Map();
let userIdCounter = 0;

// Armazenar usu√°rios banidos (por IP ou userId)
const bannedUsers = new Set();
const bannedIPs = new Set();

// Hist√≥rico de mensagens por usu√°rio (para detectar spam)
const messageHistory = new Map();

// Palavras banidas (censura)
const bannedWords = [
  'puta', 'fdp', 'caralho', 'porra', 'merda', 'viado', 'buceta', 
  'cu', 'corno', 'arrombado', 'babaca', 'desgra√ßa', 'prostituta',
  'vagabunda', 'safada', 'vadia', 'piranha', 'galinha', 'rapariga'
];

// Regex para detectar links
const urlRegex = /(https?:\/\/[^\s]+)/gi;

// ‚úÖ FUN√á√ÉO: Broadcast para todos os clientes
function broadcastEvent(type, data) {
  const message = JSON.stringify({ type, data });
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}

// ‚úÖ FUN√á√ÉO: Atualizar contador de usu√°rios online
function updateOnlineCount() {
  const count = wss.clients.size;
  console.log(`üë• Usu√°rios online: ${count}`);
  broadcastEvent('online_count', { count });
}

// ‚úÖ FUN√á√ÉO: Validar mensagem (anti-spam, censura, links)
function validateMessage(message, ws, user) {
  // 1Ô∏è‚É£ Verificar se usu√°rio est√° banido
  if (bannedUsers.has(user.id)) {
    console.log(`üö´ Usu√°rio ${user.name} est√° banido`);
    ws.send(JSON.stringify({
      type: 'user_banned',
      data: { reason: 'Voc√™ foi banido permanentemente' }
    }));
    ws.close(1008, 'Usu√°rio banido');
    return false;
  }

  // 2Ô∏è‚É£ Anti-spam: Limitar mensagens por segundo
  const now = Date.now();
  const history = messageHistory.get(user.id) || [];
  const recentMessages = history.filter(time => now - time < 5000); // √öltimos 5 segundos

  if (recentMessages.length >= 5) {
    console.log(`üö´ ${user.name} enviando spam`);
    ws.send(JSON.stringify({
      type: 'message_blocked',
      data: { reason: 'Voc√™ est√° enviando mensagens muito r√°pido!' }
    }));
    
    // Banir se continuar spammando
    if (recentMessages.length >= 10) {
      bannedUsers.add(user.id);
      broadcastEvent('user_banned_notification', {
        userName: user.name,
        reason: 'Spam excessivo'
      });
      ws.close(1008, 'Banido por spam');
    }
    return false;
  }

  messageHistory.set(user.id, [...recentMessages, now]);

  // 3Ô∏è‚É£ Verificar palavr√µes
  const lowerMessage = message.toLowerCase();
  const hasBadWord = bannedWords.some(word => lowerMessage.includes(word));
  
  if (hasBadWord) {
    console.log(`üö´ Mensagem bloqueada (palavr√£o): ${message}`);
    ws.send(JSON.stringify({
      type: 'message_blocked',
      data: { reason: 'Mensagem cont√©m palavras proibidas' }
    }));
    
    // Advert√™ncia: 3 strikes = ban
    user.warnings = (user.warnings || 0) + 1;
    if (user.warnings >= 3) {
      bannedUsers.add(user.id);
      broadcastEvent('user_banned_notification', {
        userName: user.name,
        reason: 'Uso repetido de linguagem inapropriada'
      });
      ws.close(1008, 'Banido por linguagem inapropriada');
    }
    return false;
  }

  // 4Ô∏è‚É£ Bloquear links suspeitos
  if (urlRegex.test(message)) {
    console.log(`üö´ Link bloqueado: ${message}`);
    ws.send(JSON.stringify({
      type: 'message_blocked',
      data: { reason: 'Links n√£o s√£o permitidos no chat' }
    }));
    return false;
  }

  return true;
}

// ‚úÖ CONEX√ÉO DE NOVOS CLIENTES
wss.on('connection', (ws, req) => {
  const ip = req.socket.remoteAddress;
  console.log('üîå Nova conex√£o de:', ip);

  // Verificar se IP est√° banido
  if (bannedIPs.has(ip)) {
    console.log('üö´ IP banido tentou conectar:', ip);
    ws.close(1008, 'IP banido');
    return;
  }

  const userId = ++userIdCounter;
  const user = {
    id: userId,
    name: `Usu√°rio ${userId}`,
    color: ['crimson', 'gold', 'cadetblue', 'coral', 'teal'][userId % 5],
    warnings: 0
  };

  users.set(ws, user);

  // Enviar ID do usu√°rio
  ws.send(JSON.stringify({
    type: 'user_id',
    data: user
  }));

  console.log(`‚úÖ Usu√°rio ${user.name} conectado (ID: ${userId})`);
  updateOnlineCount();

  // ‚úÖ RECEBER MENSAGENS
  ws.on('message', (msg) => {
    try {
      const message = JSON.parse(msg);
      const user = users.get(ws);
      
      console.log(`üì• Mensagem recebida - Tipo: ${message.type}, User: ${user?.name || 'DESCONHECIDO'}`);

      if (!user) {
        console.error('‚ùå ERRO: Usu√°rio n√£o encontrado no Map!');
        return;
      }

      // ‚úÖ SET_NAME COM VALIDA√á√ÉO RIGOROSA
      if (message.type === 'set_name') {
        console.log('üìù set_name recebido:', message.data, 'Tipo:', typeof message.data);
        
        // ‚úÖ VALIDA√á√ÉO CR√çTICA DO TIPO
        if (typeof message.data !== 'string') {
          console.error('‚ùå ERRO: Nome n√£o √© string!', typeof message.data, message.data);
          ws.send(JSON.stringify({
            type: 'error',
            data: { message: 'Nome inv√°lido: deve ser uma string' }
          }));
          return;
        }

        const newName = message.data.trim();
        
        // ‚úÖ VALIDA√á√ÉO DE TAMANHO
        if (!newName) {
          console.error('‚ùå ERRO: Nome vazio ap√≥s trim');
          ws.send(JSON.stringify({
            type: 'error',
            data: { message: 'Nome n√£o pode estar vazio' }
          }));
          return;
        }

        if (newName.length < 3 || newName.length > 20) {
          console.error('‚ùå ERRO: Nome com tamanho inv√°lido:', newName.length);
          ws.send(JSON.stringify({
            type: 'error',
            data: { message: 'Nome deve ter entre 3 e 20 caracteres' }
          }));
          return;
        }

        console.log(`‚úèÔ∏è Alterando nome: ${user.name} ‚Üí ${newName}`);
        user.name = newName;
        users.set(ws, user);
        updateOnlineCount();
        
        console.log('‚úÖ Nome alterado com sucesso!');
      }

      // ‚úÖ MENSAGEM DE TEXTO COM VALIDA√á√ÉO
      else if (message.type === 'message') {
        console.log(`üí¨ Processando mensagem de texto: "${message.data}"`);
        
        // ‚úÖ VALIDA√á√ÉO DO TIPO
        if (typeof message.data !== 'string') {
          console.error('‚ùå Mensagem n√£o √© string!', typeof message.data);
          ws.send(JSON.stringify({
            type: 'error',
            data: { message: 'Mensagem inv√°lida' }
          }));
          return;
        }
        
        const cleanMessage = message.data.trim();
        
        if (!cleanMessage) {
          console.log('‚ùå Mensagem vazia ap√≥s trim');
          return;
        }
        
        if (!validateMessage(cleanMessage, ws, user)) {
          console.log('‚ùå Mensagem bloqueada pela valida√ß√£o');
          return;
        }

        console.log(`üì§ Broadcasting mensagem de ${user.name}`);
        broadcastEvent('message', {
          userId: user.id,
          userName: user.name,
          content: cleanMessage,
          timestamp: Date.now()
        });
      }

      // ‚úÖ √ÅUDIO
      else if (message.type === 'audio_message') {
        console.log(`üé§ √Åudio recebido de ${user.name}`);
        
        if (!message.data || !message.data.audio) {
          console.error('‚ùå Dados de √°udio inv√°lidos');
          return;
        }
        
        broadcastEvent('audio_message', {
          userId: user.id,
          userName: user.name,
          content: message.data.audio,
          timestamp: Date.now()
        });
      }

      // ‚úÖ IMAGEM
      else if (message.type === 'image_message') {
        console.log(`üñºÔ∏è Imagem recebida de ${user.name}`);
        
        if (!message.data || !message.data.image) {
          console.error('‚ùå Dados de imagem inv√°lidos');
          return;
        }
        
        broadcastEvent('image_message', {
          userId: user.id,
          userName: user.name,
          content: message.data.image,
          fileName: message.data.fileName || 'imagem.png',
          timestamp: Date.now()
        });
      }

      // ‚úÖ V√çDEO
      else if (message.type === 'video_message') {
        console.log(`üé• V√≠deo recebido de ${user.name}`);
        
        if (!message.data || !message.data.video) {
          console.error('‚ùå Dados de v√≠deo inv√°lidos');
          ws.send(JSON.stringify({
            type: 'message_blocked',
            data: { reason: 'Dados de v√≠deo inv√°lidos' }
          }));
          return;
        }
        
        const videoSize = message.data.fileSize || 0;
        const maxSize = 500 * 1024 * 1024; // 500MB
        
        if (videoSize > maxSize) {
          console.log(`‚ùå V√≠deo muito grande: ${(videoSize / 1024 / 1024).toFixed(2)}MB`);
          ws.send(JSON.stringify({
            type: 'message_blocked',
            data: { reason: 'V√≠deo muito grande (m√°ximo 500MB)' }
          }));
          return;
        }
        
        console.log(`üì§ Broadcasting v√≠deo de ${user.name} (${(videoSize / 1024 / 1024).toFixed(2)}MB)`);
        
        broadcastEvent('video_message', {
          userId: user.id,
          userName: user.name,
          content: message.data.video,
          fileName: message.data.fileName || 'video.mp4',
          timestamp: Date.now()
        });
      }

      // ‚úÖ STICKER
      else if (message.type === 'sticker_message') {
        console.log(`üòä Sticker enviado por ${user.name}`);
        
        if (!message.data || !message.data.sticker) {
          console.error('‚ùå Dados de sticker inv√°lidos');
          return;
        }
        
        broadcastEvent('sticker_message', {
          userId: user.id,
          userName: user.name,
          content: message.data.sticker,
          timestamp: Date.now()
        });
      }

      // ‚úÖ TYPING
      else if (message.type === 'typing_start' || message.type === 'typing_stop') {
        console.log(`‚å®Ô∏è ${user.name} ${message.type === 'typing_start' ? 'come√ßou' : 'parou'} de digitar`);
        broadcastEvent('user_typing', {
          userId: user.id,
          userName: user.name,
          isTyping: message.type === 'typing_start'
        });
      }

      else {
        console.log(`‚ö†Ô∏è Tipo de mensagem desconhecido: ${message.type}`);
      }

    } catch (err) {
      console.error('‚ùå Erro ao processar mensagem:', err.message);
      console.error('‚ùå Stack:', err.stack);
    }
  });

  // ‚úÖ DESCONEX√ÉO
  ws.on('close', () => {
    const user = users.get(ws);
    if (user) {
      console.log(`üëã ${user.name} desconectou`);
      users.delete(ws);
      messageHistory.delete(user.id);
      updateOnlineCount();
    }
  });

  ws.on('error', (error) => {
    console.error('‚ùå Erro WebSocket:', error.message);
  });
});

// Iniciar servidor
server.listen(PORT, () => {
  console.log(`üöÄ Servidor WebSocket rodando na porta ${PORT}`);
});